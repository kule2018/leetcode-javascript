[621. 任务调度器](https://leetcode-cn.com/problems/task-scheduler/)

> 给定一个用字符数组表示的 CPU 需要执行的任务列表。其中包含使用大写的 A - Z 字母表示的26 种不同种类的任务。任务可以以任意顺序执行，并且每个任务都可以在 1 个单位时间内执行完。CPU 在任何一个单位时间内都可以执行一个任务，或者在待命状态。
> 
> 然而，两个相同种类的任务之间必须有长度为 n 的冷却时间，因此至少有连续 n 个单位时间内 CPU 在执行不同的任务，或者在待命状态。
> 
> 你需要计算完成所有任务所需要的最短时间。
> 
> ```
> 输入: tasks = ["A","A","A","B","B","B"], n = 2
> 输出: 8
> 执行顺序: A -> B -> (待命) -> A -> B -> (待命) -> A -> B.
> ```

【解法一】

算法原理：首先要将任务数组按出现频次由高到低排序，而且相同的任务紧挨在一起。由于相同的任务之间必须间隔 `n`，那么先把频率最高的字母放置好（暂不考虑其它字母），假设最高频次为 `m`，则队列长度至少应该是 `(m - 1) * (n + 1) + 1`，多出的一个字母作为队列末尾的边界。注意：边界字母不一定只有 1 个，这取决于最高频次的字母的数量，换言之，如果两个字母出现相同频次且最高，那么边界应该多出两个元素。 

接下去，把剩余字母同理依次插入空隙位置中，**特别注意，空隙的长度至少为 n，而不是一定为 n，所以一个空隙插入大于 n 个元素也没关系**，由于剩余字母的出现频次小于等于 `m`，所以预留的空隙一定足够，不会出现同一个元素间隔小于 n 的情况。

例如：

```js
["A","A","A","A","B","B","B","C","C","D","D"], n = 1
```

按上述分析，任务进入的过程应该是：

```
1. 安排4个A：  A -> * -> A -> * -> A -> * -> A   (至少有 n = 1 个空隙)
2. 插入3个B：  A -> B -> A -> B -> A -> B -> A
3. 插入2个C：  A -> B -> C -> A -> B -> C -> A -> B -> A    (在原空隙位置继续插入)
4. 插入1个D：  A -> B -> C -> D -> A -> B -> C -> A -> B -> A
```

所以我们只需要计算最少长度即可：`(m - 1) * (n + 1) + k`，`k` 为相同最高频次的字母数量。因此，上述例子的最小长度为 `(4 - 1) * (1 + 1) + 1 = 7`

这只是最少的情况，即空隙正好被插满或有富余，如果原数组长度更大，那么显然缝隙不够插，相当于上述例子的 3, 4 两步，则意味着最短长度就是原数组的长度。


```js
var leastInterval = function (tasks, n) {
  // 将CPU任务按出现频率由高到低排序，且相同任务紧挨着
  // 例如：["A", "A", "B", "B", "B", "C"] ==> [ 'B', 'B', 'B', 'A', 'A', 'C' ]
  let s = tasks.sort().join("").match(/(\w)\1+|\w/g).sort((a, b) => b.length - a.length).join("")
  // 最高频次
  let m = /(\w)\1+|\w/.exec(s)[0].length
  // 相同最高频次的字母个数
  let re = new RegExp(`(\\w)\\1{${m - 1}}`, "g")
  let k = s.match(re).length
  // 理论最小长度
  let minLength = (m - 1) * (n + 1) + k
  // 有可能原数组长度更大
  return Math.max(minLength, tasks.length)
};
```

【解法二】

将CPU队列的元素排列详情可视化，最终计算长度。和解法一相似，排序后一个一个推入元素，每个都要判断是否符合条件（即同一个元素间隔大于 n），不满足条件则推入空值。

```js
var leastInterval = function (tasks, n) {
  // 将CPU任务按出现频率由高到低排序，且同一个任务紧挨着，作为一个队列
  // 例如：["A", "A", "B", "B", "B", "C"] ==> [ 'B', 'B', 'B', 'A', 'A', 'C' ]
  tasks = tasks.sort().join("").match(/(\w)\1+|\w/g).sort((a, b) => b.length - a.length).join("").split("")
  // 将任务推送到真正运行的 CPU 队列中去，直到全部放进去
  let queue = []
  let len = tasks.length
  while (len > 0) {
    if (queue.length === 0) {
      queue.push(tasks.shift())
      len--
    } else {
      // 如何按要求推任务到CPU队列？
      // 遍历任务队列，CPU队列末尾 n 个元素如果不包含当前任务，则可以推进去。
      let slice = queue.slice(-n)
      for (let i = 0; i < len; i++) {
        if (!slice.includes(tasks[i])) {
          let task = tasks.splice(i, 1)
          queue.push(task[0])
          len--
          break
        }
        // 如果所有元素都不满足条件，推入空值。
        if (i === len - 1) {
          queue.push("-")
        }
      }
    }
  }
  return queue
};
```

> 注：上述代码无法满足 Leetcode 的测试用例，因为要不断遍历任务队列来推入元素，开销太大，最终超出最大时间限制。